<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Snake Game</title>
    <style>
      /* Use the provided background image (darkened) for the entire page */
      body {
        margin: 0;
        padding: 0;
        background: 
          linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),
          url("https://raw.githubusercontent.com/TOHframes/TOH_frames/refs/heads/main/bg.jpeg");
        background-size: cover;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial, sans-serif;
      }
      /* Container for the canvas, real-time score display, and overlay */
      #gameContainer {
        position: relative;
      }
      /* The playing field: a canvas with a border acting as the frame.
         We remove any CSS background so that our drawn semi-transparent fill is used. */
      canvas {
        background: transparent;
        display: block;
        border: 5px solid #000;
      }
      /* Real-time score display in the top left corner */
      #scoreDisplay {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 24px;
        z-index: 2;
      }
      /* Game Over / Win overlay styling */
      #gameOverScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-size: 36px;
        text-align: center;
        display: none;
      }
      #gameOverScreen #scoreText {
        margin-top: 10px;
        font-size: 28px;
      }
      /* Stylized Try Again button */
      #gameOverScreen button {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 24px;
        background: #8E5A2C;
        color: #fff;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.3);
        transition: background 0.3s, transform 0.2s;
      }
      #gameOverScreen button:hover {
        background: #a06d50;
        transform: scale(1.05);
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <!-- Real-time score display -->
      <div id="scoreDisplay">Score: 0</div>
      <!-- Canvas: playing field (960×640 pixels) -->
      <canvas id="gameCanvas" width="960" height="640"></canvas>
      <!-- Game Over / Win overlay -->
      <div id="gameOverScreen">
        <div id="gameOverText">Game Over</div>
        <div id="scoreText">Score: 0</div>
        <button id="tryAgainBtn">Try Again</button>
      </div>
    </div>
    <script>
      // === Global Variables & Setup ===

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const gameOverScreen = document.getElementById("gameOverScreen");
      const scoreText = document.getElementById("scoreText");
      const tryAgainBtn = document.getElementById("tryAgainBtn");
      const scoreDisplay = document.getElementById("scoreDisplay");
      const gameOverHeader = document.getElementById("gameOverText");

      // Use a grid where each cell is 40px by 40px.
      const cellSize = 40;
      const cols = canvas.width / cellSize; // 960 / 40 = 24 columns
      const rows = canvas.height / cellSize; // 640 / 40 = 16 rows

      // Game state variables
      let snake;          // Array of grid cells (each is an object {x, y})
      let direction;      // Current movement direction {x: dx, y: dy}
      let nextDirection;  // New direction chosen from key input
      let food;           // Food position {x, y}
      let gameInterval;   // ID for the game loop interval
      let score = 0;

      // Load the graphics
      const foodImage = new Image();
      foodImage.src =
        "https://raw.githubusercontent.com/TOHframes/TOH_frames/refs/heads/main/Food.png";
      const headImage = new Image();
      headImage.src =
        "https://raw.githubusercontent.com/TOHframes/TOH_frames/refs/heads/main/Hooty_head.png";

      // === Game Functions ===

      // Initialize (or reinitialize) the game state.
      function initGame() {
        // Reset the overlay header to "Game Over" (for losses).
        gameOverHeader.textContent = "Game Over";

        // Create a snake of three cells. The snake is an array of cells,
        // with the last element as the head (which uses the head image).
        const startX = Math.floor(cols / 2);
        const startY = Math.floor(rows / 2);
        snake = [
          { x: startX + 2, y: startY },
          { x: startX + 1, y: startY },
          { x: startX, y: startY } // Head (initially facing left)
        ];
        direction = { x: -1, y: 0 }; // Initially moving left.
        nextDirection = { x: -1, y: 0 };
        score = 0;
        updateScoreDisplay();
        placeFood();
        gameOverScreen.style.display = "none";
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, 100); // Run game loop every 100ms.
      }

      // Randomly place food on the grid (ensuring it doesn't appear on the snake).
      function placeFood() {
        let valid = false;
        // Calculate available free cells. (If snake occupies all cells, we cannot place food.)
        if (snake.length === cols * rows) {
          // This case should normally be caught in update() before calling placeFood().
          return;
        }
        while (!valid) {
          food = {
            x: Math.floor(Math.random() * cols),
            y: Math.floor(Math.random() * rows)
          };
          valid = !snake.some(
            (segment) => segment.x === food.x && segment.y === food.y
          );
        }
      }

      // Main game loop: update the state and redraw.
      function gameLoop() {
        update();
        draw();
        updateScoreDisplay();
      }

      // Update the snake's position and check for collisions/food.
      function update() {
        // Update current direction (ignoring reverse moves)
        if (
          nextDirection.x !== -direction.x ||
          nextDirection.y !== -direction.y
        ) {
          direction = nextDirection;
        }

        // Calculate new head position.
        const currentHead = snake[snake.length - 1];
        const newHead = {
          x: currentHead.x + direction.x,
          y: currentHead.y + direction.y
        };

        // Check for wall collisions.
        if (
          newHead.x < 0 ||
          newHead.x >= cols ||
          newHead.y < 0 ||
          newHead.y >= rows
        ) {
          endGame();
          return;
        }

        // Check if the snake is eating food.
        const eatingFood = newHead.x === food.x && newHead.y === food.y;

        // Check for self-collision.
        // When not eating, the tail cell will be removed so we can ignore it.
        let collisionBody = snake.slice();
        if (!eatingFood) {
          collisionBody.shift(); // Remove the tail from collision checking.
        }
        if (
          collisionBody.some(
            (segment) => segment.x === newHead.x && segment.y === newHead.y
          )
        ) {
          endGame();
          return;
        }

        // Add the new head.
        snake.push(newHead);

        if (eatingFood) {
          score++;
          // Check for win: if the snake fills the entire grid.
          if (snake.length === cols * rows) {
            winGame();
            return;
          }
          placeFood();
        } else {
          // Otherwise, remove the tail to simulate movement.
          snake.shift();
        }
      }

      // Draw the entire game state.
      function draw() {
        // Clear the canvas.
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw a semi-transparent white rectangle as the playing field.
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)"; // Adjust opacity as desired.
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw the food image (scaled to cell size).
        ctx.drawImage(
          foodImage,
          food.x * cellSize,
          food.y * cellSize,
          cellSize,
          cellSize
        );

        // Draw each segment of the snake.
        snake.forEach((segment, index) => {
          if (index === snake.length - 1) {
            // Draw the head with rotation.
            drawRotatedHead(segment.x, segment.y, direction);
          } else {
            // Draw a body segment as a filled square.
            ctx.fillStyle = "#8E5A2C";
            ctx.fillRect(
              segment.x * cellSize,
              segment.y * cellSize,
              cellSize,
              cellSize
            );
          }
        });
      }

      // Draw the snake head image rotated so that it faces the direction of movement.
      function drawRotatedHead(x, y, direction) {
        let angle = 0;
        // The head image originally faces left.
        if (direction.x === -1 && direction.y === 0) {
          angle = 0; // Left → no rotation.
        } else if (direction.x === 1 && direction.y === 0) {
          angle = Math.PI; // Right → 180°.
        } else if (direction.x === 0 && direction.y === -1) {
          angle = Math.PI / 2; // Up → 90° (swapped from before).
        } else if (direction.x === 0 && direction.y === 1) {
          angle = -Math.PI / 2; // Down → -90° (swapped from before).
        }

        // Compute the center of the cell.
        const centerX = x * cellSize + cellSize / 2;
        const centerY = y * cellSize + cellSize / 2;
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(angle);
        // Draw the head image centered in the cell.
        ctx.drawImage(headImage, -cellSize / 2, -cellSize / 2, cellSize, cellSize);
        ctx.restore();
      }

      // End the game (loss): stop the loop and display the Game Over overlay.
      function endGame() {
        clearInterval(gameInterval);
        scoreText.textContent = "Score: " + score;
        gameOverHeader.textContent = "Game Over";
        gameOverScreen.style.display = "flex";
      }

      // Win the game: stop the loop and display the winning overlay.
      function winGame() {
        clearInterval(gameInterval);
        scoreText.textContent = "Score: " + score;
        gameOverHeader.textContent = "Congratulations. You won.";
        gameOverScreen.style.display = "flex";
      }

      // Update the real-time score display.
      function updateScoreDisplay() {
        scoreDisplay.textContent = "Score: " + score;
      }

      // Handle arrow key input for direction changes.
      document.addEventListener("keydown", function (e) {
        switch (e.key) {
          case "ArrowLeft":
            if (direction.x !== 1) {
              nextDirection = { x: -1, y: 0 };
            }
            break;
          case "ArrowUp":
            if (direction.y !== 1) {
              nextDirection = { x: 0, y: -1 };
            }
            break;
          case "ArrowRight":
            if (direction.x !== -1) {
              nextDirection = { x: 1, y: 0 };
            }
            break;
          case "ArrowDown":
            if (direction.y !== -1) {
              nextDirection = { x: 0, y: 1 };
            }
            break;
        }
      });

      // Restart the game when "Try Again" is clicked.
      tryAgainBtn.addEventListener("click", initGame);

      // Wait for both images to load before starting the game.
      let imagesLoaded = 0;
      function onImageLoad() {
        imagesLoaded++;
        if (imagesLoaded === 2) {
          initGame();
        }
      }
      foodImage.onload = onImageLoad;
      headImage.onload = onImageLoad;
    </script>
  </body>
</html>
